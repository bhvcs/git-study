내가 유용하다고 생각하는 명령어들과 주로 사용하는 명령어에서 몰랐던 부분을 정리한다.

^(캐럿)
^ 표시는 해당 커밋의 부모를 가리킨다. 그래서 git show HEAD^ 하면 HEAD의 이전 커밋을 보여준다.
^2가 붙으면 다른 부모를 얘기한다. merge 상황에서나 가능. merge할 때 checkout한 부모가 첫번째 부모, 다른 부모가 바로 두번째 부모다.
그래서 내가 두 개의 커밋을 merge 했다? 본체 말고(checkout 한거 말고) 다른 커밋이 선택될거야.

~
^과 비슷한 기호로 ~가 있다. ~ 기호도 부모를 찾아가는데 차이는 뒤에 숫자를 붙일 때 존재한다. ^2는 두번째 부모고, HEAD~2는 부모의 부모이다.

..
범위를 나타낼 때 주로 쓰는 기호이다. 
..은 한쪽에는 속하면서 다른 한쪽에는 속하지 않는 것을 선택할 때 유용하다. 만약 master와 experiment라는 브랜치가 있다고 하자.
git log master..experiment 라고 한다면, master 브랜치에는 속하지만 experiment 브랜치에는 속하지 않는 커밋들을 보여준다.
git log origin/master..HEAD 라고 하면, 내가 push할 때 올라가게 될 커밋들이 조회될 것이다. 

...
..은 왼쪽에는 속하되, 오른쪽에는 속하지 않는 상황에 사용한다. 즉, 왼쪽에 속하는 커밋을 가리킬 것이다.
하지만 ...은 그냥 공통되지 않은 커밋을 모두 보여준다. git log master...experiment라고 한다면, master와 experiment 사이의 다른 커밋들을 시간 순서대로 보여준다.
만약 git log --left-right master..experiment까지 하면 왼쪽에 속하는 지, 오른쪽에 속하는 지 화살표로 보여줄 것이다. like < #commit

patch
여러 이슈들을 포함한 많은 부분의 수정을 하고 커밋을 하려고 한다 해보자. 그 파일의 많은 부분을 한번에 커밋하기 보다는 쪼개서 커밋하고 싶을 수 있다. 그럴 때 쓰는 것이 patch 명령어이다.
git add -p(--patch)로 해당 파일의 일부만을 커밋할 수도 있다.
이를 좀 더 응용하면, git reset -p 으로 일부만을 staging area에서 내릴 수 있고, git stash save -p 로 일부만을 stash 할 수도 있는 것이다.

git add
staging area에 올리기 위한 명령어이다. staging area에 올라간다는 건, 커밋하면 저장소에 기록될 것이라는 것.
git을 통해 파일을 관리하고 싶으면 git add로 staging area에 올리고, commit을 하면 된다.

git push
git push를 하면 로컬의 origin/master가 함께 이동한다.

git stash
인턴 와서 많이 쓰는 명령어이다. 현재의 브랜치에서 작업 중인데, 다른 브랜치로 넘어가야 할 일이 있다고 생각해보자. 하지만 수정 사항을 커밋하지 않으면 다른 브랜치로 넘어갈 수 없다. 
브랜치 이동할 때마다, 커밋을 해야 돼? 저장소의 히스토리가 더러워지겠지. 그럴 때 사용하는게 git stash다. git 내부의 스택 같은 구조에, 현재 작업 중인 스냅샷을 저장해놓는 것이다. 커밋과 비슷한 느낌이라고 할 수 있다.
git stash로 현재 작업 중이던 부분을 save 해놓고, 다른 곳에서 작업을 이어가면 된다. 다시 돌아와서 복구 시킬 때는 git stash apply stash@{번호} 로 하니씩 적용할 수 있다. 번호는 git stash list 로 내가 stash 한
리스트를 볼 수 있다. apply 만으로는 stash 스택에서 없앨 수 없으므로 drop도 매번 해줘야 한다. 이게 안전하긴 하지만 조금 귀찮다. 그래서 나는 git stash pop을 많이 사용한다. 이는 stash list에서 자동으로 없애주기
까지 한다. 
git stash는 다음과 같은 상황에서도 쓰일 수 있다고 한다.
내가 stash를 해놓았던 작업물을 꺼내서 적용해야 한다고 해보자. 그때 병합되는 상황에서 충돌이 발생하면 저장해놓은 스냅샷으로 바뀌지 못할 수도 있다. 이럴 때는 충돌을 해결해줘야 한다. 
이럴 때 사용하면 좋은 명령어가 있다. git stash branch new_branch명 이다. stash를 적용했던 브랜치 있잖아? 거기서 브랜치를 새로 만들고, 해당 브랜치에서 stash 해놓은 것들을 적용하면서 
충돌이 일어나는지 확인하는 것이다. 그러고 만약 충돌 없이 성공한다면, stash 들을 삭제한다.
나도 언제 이런 상황을 맞닥뜨린적이 있다. 하루 어떤 브랜치에서 작업을 하고 있었는데, 해당 브랜치를 리모트 저장소의 브랜치 내용으로 최신화를 하지 않은 채 작업했던 적이 있었다. 근데 이 상황에서 git pull을 한다면
내가 작업 중인 부분이 날아가게 될 것이다. 그래서 git stash를 하고 git pull을 해서 리모트로 최신화 해주고, stash pop을 했던 기억이 있다. 이때, 리모트 브랜치와 내 작업물 사이에 충돌이 있었다. 그 때마다, 일일이
해결해주면서 하나씩 pop했는데, 매우 번거로웠던 기억이 있다. 나중에 다시 이런 상황이 온다면, git stash branch new_branch명 명령어를 사용해봐야겠다.

git clean
git을 사용해 프로젝트를 진행하다보면, 내 워킹 디렉토리에 쓸모 없는 것들도 포함되어 있는 경우가 있다. 이것들을 지우는 유용한 명령어가 git clean이다. git clean -d 로 -d 옵션까지 넣으면 
워킹 디렉토리에서 하위 디렉토리까지 없애준다. git clean은 기본적으로 git에서 추적중이지 않은 모든 파일들이 삭제 대상이다. 삭제를 하는 것은 모두에게 함부로 하기 어려운 일이다. 그래서 있는게 git clean -d -n이다.
-n을 넣으면 가상으로 실행해보고 뭐가 삭제되는지 알려준다.

-- 검색

git grep
잘쓰면 좋을 것 같은 명령어이다. 프로젝트를 진행하다 보면 방대한 양의 코드들과 수많은 파일들을 볼 수 있다. 거기서 특정 함수나 변수명이 어디서 등장, 사용됐는지 찾기란 매우 어렵다. 그럴 때 사용하는 명령어.
git grep -n(--line-number) gmtime_r 명령어는 현재 워킹 디렉토리의 파일에서 gmtime_r이라는 문구들이 어느 파일에 있는지 찾아준다. -n 옵션은 그 파일의 몇 번쨰 줄에 있는지도 알려준다.
그 문자가 어디 파일에 있는지 알거나, 확인하고 싶다면 파일명도 함께 기재하면 된다.(아마 어느 파일에 있는지 모르니깐 쓰는거겠지?)
-n은 매칭되는 라인을 알려주었다면 또 유용한 옵션이 있다. -p 옵션은 해당 문구가 들어간 함수나 메서드를 찾아준다. git grep -p gmtime_r *.c 라고 한다면 c 파일 중에서, gmtime_r이 들어간 함수 or 메서드를 찾아준다.

git log
git grep은 현재 워킹 디렉토리 환경에서 찾고자 할 때 사용한다. git log는 히스토리를 검색해서, 언제 없어지고 언제 생겼고 이런 부분을 찾을 때 유용하다.
git log -S 변수이름 --oneline 명령어는 어느 커밋일 때 처음 등장했고, 어느 커밋일 때 없어졌는지 보여준다. 여기서 -S 옵션이 없다면 변수이름이 들어간 모든 커밋 히스토리들을 보여줄 것이다.
변수명만 찾아줘도 유용한데 함수 이름이나 라인까지도 찾아준다. git log -L :함수명:파일명 명령어로 함수명에 해당하는 함수의 모든 히스토리를 조회하여 Patch의 형태로 보여준다.

-- 수정
git commit --amend
가장 최근에 커밋한 커밋 메시지의 내용을 바꿀 수 있다. 이는 이미 사용해봐서 알고 있는 명령어이다. 하지만 여기에 한가지 더 유용한 기능이 있다. 커밋을 했는데 어떤 파일을 빠뜨리고 커밋한 상황을 가정해보자.
그러면 git add로 빠뜨린 파일을 staging area에 올리고 git commit --amend로 커밋을 하면, 커밋 자체가 수정되면서 해당 커밋에 파일을 추가할 수 있는 것이다. 다만 이미 push 한 커밋에 대해서는 주의를 요해야한다.
나는 커밋에 빠뜨린 파일이 있을 때 그 부분만 커밋하고 git rebase -i HEAD~2 와 같은 명령어로 수정, git push -f 로 강제로 push했다. 근데 git commit --amend를 쓰면 빠뜨린 파일을 추가적으로 올릴 때 더 유용할 
것 같다. 다만, 불필요한 커밋들을 정리할 때는 여전히 git rebase 를 이용하는게 더 유용해 보인다.

git rebase ~i HEAD~숫자
HEAD부터 숫자만큼의 커밋들을 합칠 때 사용한다. 이미 많이 사용하고 있는 명령어인데, 커밋한 것을 쪼갤 때도 유용하게 사용된다는 것을 알았다. git rebase -i 를 수행하고 나오는 프롬프트에서 edit이라는 명령어를
사용하면 가능하다. 원래 두개의 파일을 하나의 커밋으로 올렸다면, 두개의 커밋으로 쪼갠다고 해보자. edit으로하면 해당 커밋을 처리할 때 멈추고, 그때 add와 커밋을 두번 반복해서 쪼갤 수 있다. 
git rebase --continue로 남은 rebase 작업을 수행하러 간다.

git filter-branch --tree-filter
암호가 들어간 파일을 실수로 커밋했다고 해보자. 나는 지금까지 그냥 push만 안하면 되겠지, 혹은 이미 push 했다면, 삭제하면 되겠지라고 생각했다. git은 히스토리를 갖고 있으므로 제대로 삭제된게 아니다.
제대로 삭제하기 위해선 히스토리에서도 해당 파일을 제대로 삭제해야 한다. 이럴 대 사용하는게 git filter-branch이다.
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD: filter-branch로 히스토리 전체에서 필요한 것만 골라내는 도구, --tree-filter는 각 커밋에 'rm ~' 과 같이 명시된 명령어를 실행시키고, 그 결과를
다시 커밋시킨다. 여기서는 히스토리 내의 모든 커밋에서 passwords.txt를 삭제하는 것이겠다. filter-branch 명령에 추가로 --all 옵션을 
