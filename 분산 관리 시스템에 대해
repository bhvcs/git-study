Git은 분산 관리 시스템이다. 분산 관리 시스템이라는 말이 가볍게 와닿지 않는다. 분산 관리 시스템이 사용자로 하여금 어떤 것을 가능하게 하는지 알게 되면 Git에 대해 더 잘 이해 할 수 있을 것이다.

먼저 분산 환경에서의 Work flow를 살펴보겠다.

1. 중앙집중식 work flow

지금 내가 회사에서 프로젝트에 기여하는 방식이다. 나는 메인 브랜치에 직접 push 할 수 있는 권한이 없다. 하여 새로운 이슈가 있을 때, 이를 해결하기 위한 이슈 브랜치를 생성하고, 해당 브랜치에서 작업한다.
작업 후, 메인 브랜치의 관리자에게 merge request를 보낸다. 허면, 관리자는 코드를 검토하고 괜찮다 싶으면 메인 프로젝트에 merge를 시킨다.
내가 이슈 브랜치에서 작업하기 전에, 먼저 메인 브랜치의 프로젝트를 pull하여 새로이 업데이트를 한다. 다른 사람들이 적용한 변경 사항을 받아오는 것이다. 또, 관리자가 내 코드를 merge 하고 push 할 때에도,
내가 작업하는 중에 진행된 커밋이 있다면 먼저 fetch + merge로 최신화된 코드와 merge를 진행하고, 그제서야 push를 한다. 이처럼 프로젝트에 push할 상황이 오면 항상 fetch + pull로 최산화가 선행되어야 한다는 것이다.
이게 중앙집중식 work flow이고 나에겐 익숙한 것이다.

2. Integration-Manager work flow

오픈 소스 프로젝트를 예로 들면 딱 알맞다. 어떤 개발자가 오픈 소스 프로젝트를 자신의 메인 저장소에 push를 해놓은 상황을 생각해보자. 다른 개발자들은 해당 저장소에 쓸 수 있는 권한이 없다.
그럼 이들은 프로젝트에 어떻게 기여하느냐? 메인 프로젝트를 fork하고 자신의 remote 저장소에 수정 사항을 올려 놓는다. 그런 후에, Integration Manager에게 나 이거 했는데 좀 봐라 라고 요청을 보낼 것이다.
그러면 Integration Manager는 다른 개발자의 저장소를 remote 저장소로 두고, 코드를 받아와서 테스트를 해볼 것이다. 그렇게 해당 작업이 마음에 들면 자신의 프로젝트와 merge를 해서 push까지 할 것이다. 이러면
기여자의 코드가 메인 프로젝트에 반영되는 것이다.

3. Dictator and Lieutenants work flow

Integration-Manager work flow에서 하나의 매니저가 최종 매니저와 중간 매니저들, 이렇게 두 단계로 분화된 느낌이다. 실제 대규모의 오픈 소스 프로젝트에서 이러한 방법을 사용한다. 여기에 참여하고자 하는 개발자는
작업을 merge하기 전에 메인 브랜치(메인 프로젝트의)를 기준으로 rebase가 선행되어야 한다.
-- 왜 rebase를 하는 것일까?
